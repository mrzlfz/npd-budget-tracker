/**
 * This file is auto-generated by Convex.
 *
 * To reenerate, run:
 *   npx convex dev
 */

import type {
  FunctionHandle,
  Query,
  Mutation,
  Action,
  AnyApi,
  ApiFromModules,
  MakeOptional,
  Filter,
  PaginationOptions,
  PaginationResult,
} from "convex/server";

import type {
  ArgumentTypes,
  ReturnType,
  RegisteredValidators,
} from "convex/values";

import type { Id } from "./_generated/id";
import type {
  Organization,
  User,
  RKADocument,
  RKASubkegiatan,
  RKAKegiatan,
  RKAProgram,
  RKAAccount,
  NPDDocument,
  NPDLine,
  SP2DRef,
  Realization,
  PerformanceLog,
  Attachment,
  NPDFile,
  AuditLog,
} from "../schema";

// Define your API here
export const api = {
  organizations: {
    get: query({
      args: {},
      handler: async (ctx) => {
        return await ctx.db.query("organizations").collect();
      },
    }),
    getById: query({
      args: { id: v.id("organizations") },
      handler: async (ctx, { id }) => {
        return await ctx.db.get(id);
      },
    }),
    create: mutation({
      args: {
        name: v.string(),
        description: v.optional(v.string()),
        clerkOrganizationId: v.string(),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const org = await ctx.db.insert("organizations", {
          name: args.name,
          description: args.description,
          clerkOrganizationId: args.clerkOrganizationId,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        return org;
      },
    }),
  },

  users: {
    getByOrganization: query({
      args: { organizationId: v.id("organizations") },
      handler: async (ctx, { organizationId }) => {
        return await ctx.db
          .query("users")
          .withIndex("by_organization", q => q.eq("organizationId", organizationId))
          .collect();
      },
    }),
    create: mutation({
      args: {
        clerkUserId: v.string(),
        email: v.string(),
        name: v.optional(v.string()),
        organizationId: v.id("organizations"),
        role: v.string(),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const user = await ctx.db.insert("users", {
          clerkUserId: args.clerkUserId,
          email: args.email,
          name: args.name,
          organizationId: args.organizationId,
          role: args.role,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        return user;
      },
    }),
  },

  rka: {
    getPrograms: query({
      args: {
        organizationId: v.id("organizations"),
        fiscalYear: v.optional(v.number()),
      },
      handler: async (ctx, { organizationId, fiscalYear }) => {
        let query = ctx.db
          .query("rkaPrograms")
          .withIndex("by_organization", q => q.eq("organizationId", organizationId));

        if (fiscalYear) {
          query = query.withIndex("by_organization_fiscal_year", q =>
            q.eq("organizationId", organizationId).eq("fiscalYear", fiscalYear)
          );
        }

        return await query.collect();
      },
    }),

    getKegiatans: query({
      args: { programId: v.id("rkaPrograms") },
      handler: async (ctx, { programId }) => {
        return await ctx.db
          .query("rkaKegiatans")
          .withIndex("by_program", q => q.eq("programId", programId))
          .collect();
      },
    }),

    getSubkegiatans: query({
      args: { kegiatanId: v.id("rkaKegiatans") },
      handler: async (ctx, { kegiatanId }) => {
        return await ctx.db
          .query("rkaSubkegiatans")
          .withIndex("by_kegiatan", q => q.eq("kegiatanId", kegiatanId))
          .collect();
      },
    }),

    getAccounts: query({
      args: {
        subkegiatanId: v.id("rkaSubkegiatans"),
        organizationId: v.id("organizations"),
      },
      handler: async (ctx, { subkegiatanId, organizationId }) => {
        return await ctx.db
          .query("rkaAccounts")
          .withIndex("by_subkegiatan", q => q.eq("subkegiatanId", subkegiatanId))
          .filter(q => q.eq("organizationId", organizationId))
          .collect();
      },
    }),

    getAccountById: query({
      args: { accountId: v.id("rkaAccounts") },
      handler: async (ctx, { accountId }) => {
        return await ctx.db.get(accountId);
      },
    }),
  },

  npd: {
    getDocuments: query({
      args: {
        organizationId: v.id("organizations"),
        status: v.optional(v.string()),
        tahun: v.optional(v.number()),
      },
      handler: async (ctx, { organizationId, status, tahun }) => {
        let query = ctx.db
          .query("npdDocuments")
          .withIndex("by_organization", q => q.eq("organizationId", organizationId));

        if (status) {
          query = query.withIndex("by_status", q =>
            q.eq("organizationId", organizationId).eq("status", status)
          );
        }

        if (tahun) {
          query = query.withIndex("by_organization_tahun", q =>
            q.eq("organizationId", organizationId).eq("tahun", tahun)
          );
        }

        return await query.order("desc").collect();
      },
    }),

    getById: query({
      args: { id: v.id("npdDocuments") },
      handler: async (ctx, { id }) => {
        return await ctx.db.get(id);
      },
    }),

    getLines: query({
      args: { npdId: v.id("npdDocuments") },
      handler: async (ctx, { npdId }) => {
        return await ctx.db
          .query("npdLines")
          .withIndex("by_npd", q => q.eq("npdId", npdId))
          .collect();
      },
    }),

    createDocument: mutation({
      args: {
        title: v.string(),
        description: v.optional(v.string()),
        jenis: v.string(), // "UP", "GU", "TU", "LS"
        subkegiatanId: v.id("rkaSubkegiatans"),
        organizationId: v.id("organizations"),
        tahun: v.number(),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        // Generate document number
        const documentNumber = await generateDocumentNumber(ctx, args.organizationId, args.tahun);

        const npd = await ctx.db.insert("npdDocuments", {
          title: args.title,
          description: args.description,
          documentNumber,
          jenis: args.jenis,
          subkegiatanId: args.subkegiatanId,
          status: "draft",
          organizationId: args.organizationId,
          createdBy: identity.subject,
          tahun: args.tahun,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        return npd;
      },
    }),

    addLine: mutation({
      args: {
        npdId: v.id("npdDocuments"),
        accountId: v.id("rkaAccounts"),
        uraian: v.string(),
        jumlah: v.number(),
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        // Check budget validation
        const account = await ctx.db.get(args.accountId);
        if (!account) {
          throw new Error("Account not found");
        }

        if (args.jumlah > account.sisaPagu) {
          throw new Error(`Jumlah melebihi sisa pagu. Sisa pagu: ${account.sisaPagu}, Diminta: ${args.jumlah}`);
        }

        const line = await ctx.db.insert("npdLines", {
          npdId: args.npdId,
          accountId: args.accountId,
          uraian: args.uraian,
          jumlah: args.jumlah,
          createdAt: Date.now(),
          updatedAt: Date.now(),
        });

        // Update sisa pagu
        await ctx.db.patch(args.accountId, {
          sisaPagu: account.sisaPagu - args.jumlah,
          updatedAt: Date.now(),
        });

        return line;
      },
    }),

    submitDocument: mutation({
      args: { npdId: v.id("npdDocuments") },
      handler: async (ctx, { npdId }) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const npd = await ctx.db.get(npdId);
        if (!npd) {
          throw new Error("NPD not found");
        }

        if (npd.status !== "draft") {
          throw new Error("Only draft documents can be submitted");
        }

        const updatedNpd = await ctx.db.patch(npdId, {
          status: "diajukan",
          updatedAt: Date.now(),
        });

        return updatedNpd;
      },
    }),

    verifyDocument: mutation({
      args: { npdId: v.id("npdDocuments") },
      handler: async (ctx, { npdId }) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const npd = await ctx.db.get(npdId);
        if (!npd) {
          throw new Error("NPD not found");
        }

        if (npd.status !== "diajukan") {
          throw new Error("Only submitted documents can be verified");
        }

        const updatedNpd = await ctx.db.patch(npdId, {
          status: "diverifikasi",
          verifiedBy: identity.subject,
          verifiedAt: Date.now(),
          updatedAt: Date.now(),
        });

        return updatedNpd;
      },
    }),

    finalizeDocument: mutation({
      args: {
        npdId: v.id("npdDocuments"),
        catatan: v.optional(v.string()),
      },
      handler: async (ctx, { npdId, catatan }) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const npd = await ctx.db.get(npdId);
        if (!npd) {
          throw new Error("NPD not found");
        }

        if (npd.status !== "diverifikasi") {
          throw new Error("Only verified documents can be finalized");
        }

        const updatedNpd = await ctx.db.patch(npdId, {
          status: "final",
          finalizedBy: identity.subject,
          finalizedAt: Date.now(),
          catatan,
          updatedAt: Date.now(),
        });

        return updatedNpd;
      },
    }),
  },

  files: {
    upload: mutation({
      args: {
        npdId: v.id("npdDocuments"),
        filename: v.string(),
        fileType: v.string(),
        fileSize: v.number(),
        fileUrl: v.string(),
        jenis: v.string(), // "RAB", "BAST", "Kontrak", dll
      },
      handler: async (ctx, args) => {
        const identity = await ctx.auth.getUserIdentity();
        if (!identity) {
          throw new Error("Not authenticated");
        }

        const file = await ctx.db.insert("npdFiles", {
          npdId: args.npdId,
          filename: args.filename,
          fileType: args.fileType,
          fileSize: args.fileSize,
          fileUrl: args.fileUrl,
          status: "uploaded",
          uploadedBy: identity.subject,
          organizationId: identity.orgId,
          uploadedAt: Date.now(),
          createdAt: Date.now(),
        });

        return file;
      },
    }),

    getByNpd: query({
      args: { npdId: v.id("npdDocuments") },
      handler: async (ctx, { npdId }) => {
        return await ctx.db
          .query("npdFiles")
          .withIndex("by_npd", q => q.eq("npdId", npdId))
          .collect();
      },
    }),
  },
} satisfies AnyApi;

// Helper function to generate document numbers
async function generateDocumentNumber(
  ctx: any,
  organizationId: Id<"organizations">,
  tahun: number
): Promise<string> {
  const currentYear = new Date().getFullYear();

  // Get existing NPDs for this organization and year
  const existingNpds = await ctx.db
    .query("npdDocuments")
    .withIndex("by_organization_tahun", q =>
      q.eq("organizationId", organizationId).eq("tahun", tahun)
    )
    .collect();

  const sequence = existingNpds.length + 1;

  // Get organization code (you might want to store this in organizations table)
  const organization = await ctx.db.get(organizationId);
  const orgCode = organization?.clerkOrganizationId.slice(-4) || "ORG"; // Last 4 chars as default

  return `NPD-${orgCode}-${tahun}-${sequence.toString().padStart(3, '0')}`;
}

export default api;